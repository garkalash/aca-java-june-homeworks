--Insert some data into a table
INSERT INTO cd.facilities (facid,name,membercost,guestcost,initialoutlay, monthlymaintenance)
VALUES(9,'Spa',20,30,100000,800),
        (10,'Squash Court 2', 3.5, 17.5, 5000, 80);

--Insert calculated data into a table
INSERT INTO cd.facilities (facid,name,membercost,guestcost,initialoutlay, monthlymaintenance)
VALUES((SELECT max(facid) from cd.facilities)+1,'Spa',20,30,100000,800);

DELETE FROM cd.facilities
    WHERE facid = 11;

--Update some existing data
UPDATE cd.facilities
SET initialoutlay = 10000
WHERE facid = 1;

--Update multiple rows and columns at the same time
UPDATE cd.facilities
SET membercost = 6,
    guestcost = 30
WHERE name::text like 'Tennis Court%';

SELECT * FROM cd.facilities;

--Update a row based on the contents of another row
UPDATE cd.facilities
SET
    membercost = (SELECT membercost * 1.1 FROM cd.facilities WHERE facid = 0),
    guestcost = (SELECT guestcost * 1.1 FROM cd.facilities WHERE facid = 0)

WHERE facid = 1;

--Delete all bookings
DELETE FROM cd.bookings;

SELECT *FROM cd.members;

--Delete a member from the cd.members table
DELETE FROM cd.members
WHERE memid = 37;

--Delete based on a subquery
DELETE FROM cd.members
WHERE memid NOT IN (SELECT memid FROM cd.bookings);

--Retrieve everything from a table
SELECT *FROM cd.facilities;

--Retrieve specific columns from a table
SELECT name, membercost FROM cd.facilities;

--Control which rows are retrieved
SELECT *FROM cd.facilities
WHERE membercost > 0;

--Control which rows are retrieved - part 2
SELECT facid,name,membercost,monthlymaintenance FROM cd.facilities
WHERE membercost >0
  AND membercost < monthlymaintenance/50;

--Basic string searches
SELECT *FROM cd.facilities
WHERE name LIKE '%Tennis%';

--How can you retrieve the details of facilities with ID 1 and 5? Try to do it without using the OR operator.
SELECT *FROM cd.facilities
WHERE facid = 1 OR facid = 5;

SELECT *FROM cd.facilities
WHERE facid in(1,5);

--Working with dates
SELECT memid, surname, firstname, joindate FROM cd.members
WHERE joindate > '2012-09-01';

--Removing duplicates, and ordering results
SELECT distinct surname FROM cd.members
GROUP BY surname
ORDER BY surname
LIMIT 10;

--Count the number of facilities
SELECT count(*) FROM cd.facilities;


--You'd like to get the signup date of your last member.
SELECT joindate FROM cd.members
ORDER BY joindate DESC
LIMIT 1;


--Count the number of expensive facilities
SELECT count(*) FROM cd.facilities
WHERE guestcost > 10;

--Produce a count of the number of recommendations each member has made. Order by member ID.
SELECT recommendedby, count(*) FROM cd.members
WHERE recommendedby > 0
GROUP BY recommendedby
ORDER BY recommendedby;

--List the total slots booked per facility
SELECT facid, sum(slots) FROM cd.bookings
GROUP BY facid
ORDER BY facid;

--List the total slots booked per facility in a given month
SELECT facid, sum(slots) FROM cd.bookings
WHERE starttime >= '2012-09-01'
    AND starttime < '2012-10-01'
GROUP BY facid
ORDER BY sum(slots);

--Find the count of members who have made at least one booking
SELECT count(distinct memid) FROM cd.bookings;

--List facilities with more than 1000 slots booked
SELECT facid, sum(slots) from cd.bookings
GROUP BY facid
HAVING sum(slots) > 1000
ORDER BY facid;

--Output the facility id that has the highest number of slots booked
SELECT facid, sum(slots) from cd.bookings
GROUP BY facid
ORDER BY sum(slots) desc
LIMIT 1;

--How can you produce a list of the start times for bookings by members named 'David Farrell'?
SELECT starttime FROM cd.bookings b
INNER JOIN cd.members m ON m.memid = b.memid
WHERE m.firstname = 'David'
  AND m.surname = 'Farrell';

--How can you produce a list of the start times for bookings for tennis courts, for the date '2012-09-21'?
--Return a list of start time and facility name pairings, ordered by the time.
SELECT starttime AS start, name FROM cd.facilities f
INNER JOIN cd.bookings b ON b.facid = f.facid
WHERE b.starttime >= '2012-09-21'
  AND b.starttime < '2012-09-22'
  AND f.name LIKE 'Tennis Court%'
ORDER BY b.starttime;

--How can you output a list of all members who have recommended another member?
--Ensure that there are no duplicates in the list, and that results are ordered by (surname, firstname).
SELECT distinct b.firstname, b.surname FROM cd.members m
INNER JOIN cd.members b ON b.memid = m.recommendedby
ORDER BY surname, firstname;

--How can you output a list of all members, including the individual who recommended them (if any)?
--Ensure that results are ordered by (surname, firstname).
SELECT b.firstname AS memfname, b.surname AS memsname, m.firstname AS recfname, m.surname AS recsname
FROM cd.members b
LEFT JOIN cd.members m ON m.memid = b.recommendedby
ORDER BY memsname, memfname;

--How can you produce a list of all members who have used a tennis court? Include in your output the name of the court,
--and the name of the member formatted as a single column. Ensure no duplicate data, and order by the member name.
SELECT DISTINCT m.firstname || ' ' || m.surname AS member, f.name AS facility FROM cd.members m
INNER JOIN cd.bookings b ON m.memid = b.memid
INNER JOIN cd.facilities f ON b.facid = f.facid
WHERE f.name LIKE 'Tennis Court%'
ORDER BY member;

--How can you produce a list of bookings on the day of 2012-09-14 which will cost the member (or guest) more than $30?
-- Remember that guests have different costs to members (the listed costs are per half-hour 'slot'),
-- and the guest user is always ID 0. Include in your output the name of the facility,
-- the name of the member formatted as a single column, and the cost. Order by descending cost,
-- and do not use any subqueries.
SELECT m.firstname || ' ' || m.surname AS member, f.name AS facility,
       CASE
           WHEN m.memid = 0 THEN b.slots*f.guestcost
           WHEN m.memid !=0 THEN b.slots*f.membercost
       END AS cost FROM cd.members m
INNER JOIN cd.bookings b ON m.memid = b.memid
INNER JOIN cd.facilities f ON b.facid = f.facid
WHERE b.starttime >= '2012-09-14'
    AND b.starttime < '2012-09-15'
    AND ((m.memid = 0 AND b.slots*f.guestcost > 30) OR
     (m.memid != 0 AND b.slots*f.membercost > 30))
ORDER BY cost DESC;

--How can you output a list of all members, including the individual who recommended them (if any),
-- without using any joins? Ensure that there are no duplicates in the list,
-- and that each firstname + surname pairing is formatted as a column and ordered.
SELECT DISTINCT m.firstname || ' ' || m.surname AS member,
                (SELECT n.firstname || ' ' || n.surname AS recommender
FROM cd.members n
WHERE n.memid = m.recommendedby) FROM cd.members m
ORDER BY member;

--The Produce a list of costly bookings exercise contained some messy logic: we had to calculate the booking cost in
-- both the WHERE clause and the CASE statement. Try to simplify this calculation using subqueries.
SELECT  member, facility, cost FROM (
    SELECT m.firstname || ' ' || m.surname as member, f.name as facility,
            case WHEN m.memid = 0 THEN b.slots * f.guestcost
                 WHEN m.memid !=0 THEN b.slots * f.membercost
                END AS cost FROM cd.members m
INNER JOIN cd.bookings b ON m.memid = b.memid
INNER JOIN cd.facilities f ON b.facid = f.facid
WHERE starttime >= '2012-09-14'
    AND starttime < '2012-09-15') AS n
WHERE  cost > 30
ORDER BY cost DESC;

--Produce a list of facilities along with their total revenue.
--The output table should consist of facility name and revenue, sorted by revenue
SELECT name,sum(slots*
        CASE
        WHEN memid = 0 THEN guestcost
        WHEN membercost
        END) AS revenue
    FROM cd.bookings b
INNER JOIN cd.facilities f ON b.facid = f.facid
GROUP BY f.name
ORDER BY revenue;


--Produce a list of facilities with a total revenue less than 1000.
--Produce an output table consisting of facility name and revenue, sorted by revenue
SELECT name, revenue FROM
        (SELECT f.name, sum(slots*
                        CASE
                        WHEN memid = 0 THEN guestcost
                        ELSE membercost
                        END) AS revenue
        FROM cd.bookings b
INNER JOIN cd.facilities f ON b.facid = f.facid
GROUP BY f.name) AS f1
WHERE revenue < 1000
ORDER BY revenue;

--Produce a list of the total number of hours booked per facility, remembering that a slot lasts half an hour.
--The output table should consist of the facility id, name, and hours booked, sorted by facility id
SELECT facid, name, total_hours FROM
    (SELECT f.facid, f.name, sum(slots)/2 AS total_hours
     FROM cd.bookings b
INNER JOIN cd.facilities f ON f.facid = b.facid
GROUP BY f.facid, f.name
ORDER BY f.facid ) AS f1;


--Produce a list of the total number of hours booked per facility, remembering that a slot lasts half an hour.
--The output table should consist of the facility id, name, and hours booked, sorted by facility id.
SELECT f.facid, f.name, to_char(sum(slots)/2.0, '999D99') AS total_hours
    FROM cd.bookings b
INNER JOIN cd.facilities f ON f.facid = b.facid
GROUP BY f.facid, f.name
ORDER BY f.facid;

--Produce a list of each member name, id, and their first booking after September 1st 2012. Order by member ID
SELECT m.surname, m.firstname, m.memid, min(starttime) AS starttime
    FROM cd.bookings b
INNER JOIN cd.members m ON m.memid = b.memid
WHERE starttime >= '2012-09-01'
GROUP BY m.surname, m.firstname, m.memid
ORDER BY m.memid;

--Produce a list of member names, with each row containing the total member count. Order by join date.
SELECT (SELECT count(*) FROM cd.members) AS count, firstname, surname
FROM cd.members
ORDER BY joindate;

--Produce a monotonically increasing numbered list of members, ordered by their date of joining.
--Remember that member IDs are not guaranteed to be sequential.
SELECT ROW_NUMBER() OVER(ORDER BY joindate) AS row_number, firstname, surname
FROM cd.members;

--Output the facility id that has the highest number of slots booked.
--Ensure that in the event of a tie, all tieing results get output
SELECT facid, total FROM
(SELECT facid, sum(slots) AS total, RANK() OVER(ORDER BY sum(slots) DESC) as rank
FROM cd.bookings
GROUP BY facid) AS total
WHERE rank = 1;

--Rank members by (rounded) hours used
SELECT firstname, surname, hours, rank() over (order by hours desc) as rank from
      (SELECT firstname, surname, (sum(slots*0.5)/10)*10 as hours from cd.bookings b
INNER JOIN cd.members m ON b.memid = m.memid
GROUP BY m.memid ) as rank
ORDER BY rank;

--Find the top three revenue generating facilities
SELECT name, rank() over (order by sum(case when memid = 0 then guestcost * slots
                                            else membercost * slots
    end) DESC) as revenue from cd.facilities f
INNER JOIN cd.bookings b on f.facid = b.facid
GROUP BY f.name
ORDER BY revenue
LIMIT 3;

--Classify facilities into equally sized groups of high, average, and low based on their revenue
SELECT name, case when position = 1 then 'high'
    when position = 2 then 'average'
    else 'low'
    end as revenue from
    (SELECT f.name as name, ntile(3) over (order by sum(case when memid = 0 then slots * guestcost
    else slots * membercost end) DESC) as position from cd.bookings b
INNER JOIN cd.facilities f on f.facid = b.facid
GROUP BY f.name) as rank
ORDER BY position;

--Calculate the payback time for each facility
SELECT f.name, f.initialoutlay/ (sum(case when memid = 0 then f.guestcost*slots
    else f.membercost*slots end)/3 - f.monthlymaintenance) as months FROM cd.bookings b
INNER JOIN cd.facilities f ON b.facid = f.facid
GROUP BY f.facid, f.name
ORDER BY f.name;

--Calculate a rolling average of total revenue
SELECT date,
(SELECT sum(case when memid = 0 then slots * guestcost
                 else slots * membercost end) as revenue FROM cd.bookings b
INNER JOIN cd.facilities f on b.facid = f.facid
    WHERE b.starttime >= date - interval '14' day
    AND b.starttime < date + interval '1' day)/15 as revenue FROM
     (SELECT cast(GENERATE_SERIES(date '2012-08-01', '2012-08-31', '1 day')as date) as date) as d
ORDER BY date;
